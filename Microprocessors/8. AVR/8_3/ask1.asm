.include "m16def.inc"

.DSEG
_tmp_: .byte 2
.CSEG

.org 0x0000
rjmp main

main: 

    ldi r24,low(RAMEND) ;initialize stack pointer
    out spl,r24
    ldi r24,high(RAMEND)
    out sph,r24
    clr r17            
    out DDRB, r17   ; PORTB as input. 
    ser r26         ; a?????p???s? t?? PORT?
    out DDRA , r26  ; ??a ???d?
    ldi r17, 0xfc
    out DDRD, r17 ; PD2-7 as output (LCD screen).
    ldi r23 , 1
    rcall lcd_init ; Initialize LCD screen.

flash:
   in r17,PINB	    ; input in r17
   cp r23,r17
   breq flash

  ; push r17      ; Save input number on stack. ; xreiazetai ??
tag13:
   rcall wipe_screen ; Perform screen wipe.
   mov r23,r17
   ldi r24,'1'
   sbrs r17,7    ; Skip if bit 7 in r17 is set
   ldi r24,'0'
   rcall lcd_data
   ldi r24,'1'
   sbrs r17,6
   ldi r24,'0'
   rcall lcd_data
   ldi r24,'1'
   sbrs r17,5
   ldi r24,'0'
   rcall lcd_data
   ldi r24,'1'
   sbrs r17,4
   ldi r24,'0'
   rcall lcd_data
   ldi r24,'1'
   sbrs r17,3
   ldi r24,'0'
   rcall lcd_data
   ldi r24,'1'
   sbrs r17,2
   ldi r24,'0'
   rcall lcd_data
   ldi r24,'1'
   sbrs r17,1
   ldi r24,'0'
   rcall lcd_data
   ldi r24,'1'
   sbrs r17,0
   ldi r24,'0'
   rcall lcd_data
   ldi r24,'='
   rcall lcd_data
   ldi r24,'+'	
   sbrc r17,7      ; Skip if bit 7 in r17 cleared
   rcall _complement_
   rcall lcd_data
   ldi r18,0       ; initialize hundrens
   ldi r19,0       ; initialize decades
                    ; BCD



tag1:
    cpi r17,100
	brlo tag2
	subi r17,100
	ldi r18,1
 tag2:
    cpi r17,10
	brlo tag3
	subi r17,10
	inc  r19
	rjmp tag2
tag3:
    ldi r16,48
    add r18,r16
	add r19,r16
	add r17,r16 
    mov r24, r18
	cpi r24, 48       ; if it is zero don't print it
	breq tag4
    rcall lcd_data     
	mov r24 , r19
    rcall lcd_data 
	rjmp tag5
tag4:
    mov r24 , r19
	cpi r24, 48       ; if it is zero don't print it
	breq tag5
    rcall lcd_data
tag5:
    mov r24 , r17
	rcall lcd_data
    rjmp flash

_complement_:       ; two's complement
    com r17
	inc r17
	ldi r24,'-'
	ret

lcd_init:
  ldi r24 ,40 ; ?ta? ? e?e??t?? t?? lcd t??f?d?te?ta? µe
  ldi r25 ,0 ; ?e?µa e?te?e? t?? d??? t?? a?????p???s?.
  rcall wait_msec ; ??aµ??? 40 msec µ???? a?t? ?a ?????????e?.
  ldi r24 ,0x30 ; e?t??? µet?ﬂas?? se 8 bit mode
  out PORTD ,r24 ; epe?d? de? µp????µe ?a e?µaste ﬂ?ﬂa???
  sbi PORTD ,PD3 ; ??a t? d?aµ??f?s? e?s?d?? t?? e?e??t?
  cbi PORTD ,PD3 ; t?? ??????, ? e?t??? ap?st???eta? d?? f????
  ldi r24 ,39
  ldi r25 ,0 ; e?? ? e?e??t?? t?? ?????? ﬂ??s?eta? se 8-bit mode
  rcall wait_usec ; de? ?a s?µﬂe? t?p?ta, a??? a? ? e?e??t?? ??e? d?aµ??f?s?
                  ; e?s?d?? 4 bit ?a µetaﬂe? se d?aµ??f?s? 8 bit
  ldi r24 ,0x30
  out PORTD ,r24
  sbi PORTD ,PD3
  cbi PORTD ,PD3
  ldi r24 ,39
  ldi r25 ,0
  rcall wait_usec

 ldi r24 ,0x20 ; a??a?? se 4-bit mode
 out PORTD ,r24
 sbi PORTD ,PD3
 cbi PORTD ,PD3
 ldi r24 ,39
 ldi r25 ,0
 rcall wait_usec

 ldi r24 ,0x28 ; ep????? ?a?a?t???? µe?????? 5x8 ?????d??
 rcall lcd_command ; ?a? eµf???s? d?? ??aµµ?? st?? ?????
 ldi r24 ,0x0c ; e?e???p???s? t?? ??????, ap?????? t?? ???s??a
 rcall lcd_command
 ldi r24 ,0x01 ; ?a?a??sµ?? t?? ??????
 rcall lcd_command
 ldi r24 ,low(1530)
 ldi r25 ,high(1530)
 rcall wait_usec

 ldi r24 ,0x06 ; e?e???p???s? a?t?µat?? a???s?? ?at? 1 t?? d?e????s??
 rcall lcd_command ; p?? e??a? ap????e?µ??? st?? µet??t? d?e????se?? ?a?
                   ; ape?e???p???s? t?? ???s??s?? ????????? t?? ??????
 ret
lcd_command:
  cbi PORTD ,PD2 ; ep????? t?? ?ata????t? e?t???? (PD2=0)
  rcall write_2_nibbles ; ap?st??? t?? e?t???? ?a? a?aµ??? 39µsec
  ldi r24 ,39 ; ??a t?? ????????s? t?? e?t??es?? t?? ap? t?? e?e??t? t?? lcd.
  ldi r25 ,0 ; S??.: ?p?????? d?? e?t????, ?? clear display ?a? return home,
  rcall wait_usec ; p?? apa?t??? s?µa?t??? µe?a??te?? ??????? d??st?µa.
  ret

lcd_data:
 sbi PORTD ,PD2 ; ep????? t?? ?ata????t? ded?µ???? (PD2=1)
 rcall write_2_nibbles ; ap?st??? t?? byte
 ldi r24 ,43 ; a?aµ??? 43µsec µ???? ?a ?????????e? ? ????
 ldi r25 ,0 ; t?? ded?µ???? ap? t?? e?e??t? t?? lcd
 rcall wait_usec
 ret

write_2_nibbles:
  push r24 ; st???e? ta 4 MSB
  in r25 ,PIND ; d?aﬂ????ta? ta 4 LSB ?a? ta ?a?ast?????µe
  andi r25 ,0x0f ; ??a ?a µ?? ?a??s??µe t?? ?p??a p??????µe?? ?at?stas?
  andi r24 ,0xf0 ; ap?µ??????ta? ta 4 MSB ?a?
  add r24 ,r25 ; s??d?????ta? µe ta p???p?????ta 4 LSB
  out PORTD ,r24 ; ?a? d????ta? st?? ???d?
  sbi PORTD ,PD3 ; d?µ?????e?ta? pa?µ?? ?nable st?? a???d??t? PD3
  cbi PORTD ,PD3 ; PD3=1 ?a? µet? PD3=0
  pop r24 ; st???e? ta 4 LSB. ??a?t?ta? t? byte.
  swap r24 ; e?a???ss??ta? ta 4 MSB µe ta 4 LSB
  andi r24 ,0xf0 ; p?? µe t?? se??? t??? ap?st?????ta?
  add r24 ,r25
  out PORTD ,r24
  sbi PORTD ,PD3 ; ???? pa?µ?? ?nable
  cbi PORTD ,PD3
  ret

; == wipe_screen ==
; Wipes the LCD screen. Assumes screen controller has initialized correctly.
; Note: Approx. 1.5sec delay caused as a result of command processing.
; MODIFIES: r24, r25
wipe_screen:
  ldi r24, 0x01 ; Issue a screen-wipe command.
  rcall lcd_command ;
  ldi r24, low(1530) ; Delay for 1.5msec until command is processed.
  ldi r25, high(1530)
  rcall wait_usec
  ret ; Return to caller.

wait_usec:
 sbiw r24 ,1 ; 2 ?????? (0.250 µsec)
 nop ; 1 ?????? (0.125 µsec)
 nop ; 1 ?????? (0.125 µsec)
 nop ; 1 ?????? (0.125 µsec)
 nop ; 1 ?????? (0.125 µsec)
 brne wait_usec ; 1 ? 2 ?????? (0.125 ? 0.250 µsec)
 ret ; 4 ?????? (0.500 µsec)

wait_msec:
 push r24 ; 2 ?????? (0.250 µsec)
 push r25 ; 2 ??????
 ldi r24 , low(998) ; f??t?se t?? ?ata?. r25:r24 µe 998 (1 ?????? - 0.125 µsec)
 ldi r25 , high(998) ; 1 ?????? (0.125 µsec)
 rcall wait_usec ; 3 ?????? (0.375 µsec), p???a?e? s??????? ?a??st???s? 998.375 µsec
 pop r25 ; 2 ?????? (0.250 µsec)
 pop r24 ; 2 ??????
 sbiw r24 , 1 ; 2 ??????
 brne wait_msec ; 1 ? 2 ?????? (0.125 ? 0.25
 ret ; 4 ?????? (0.500 µsec)


;************KEYBOARD_TO_ASCII*********
keyboard_to_ascii:
; Input: r24 with an integer
; Output: r24 the ascii character that corresponds to that integer
; Uses: r27:r26, r25:r24
	movw r26, r24 		; move input to r26:r25
	ldi r24, '*'		; in r26 are these symbols
	sbrc r26, 0			; C 9 8 7 D # 0 *
	ret
	ldi r24, '0'
	sbrc r26, 1
	ret
	ldi r24, '#'
	sbrc r26, 2
	ret
	ldi r24, 'D'
	sbrc r26, 3 		; if not '1' ignores ret, otherwise
	ret 				; returns with r24 set to D.
	ldi r24, '7'
	sbrc r26, 4
	ret
	ldi r24, '8'
	sbrc r26, 5
	ret
	ldi r24, '9'
	sbrc r26, 6
	ret
	ldi r24, 'C'
	sbrc r26, 7
 	ret
 	ldi r24, '4' 		; logical '1' in these places of r27 suggest that there
	sbrc r27, 0 		; are A 3 2 1 B 6 5 4
	ret
	ldi r24, '5'
	sbrc r27, 1
	ret
	ldi r24, '6'
	sbrc r27, 2
	ret
	ldi r24, 'B'
	sbrc r27, 3
	ret
	ldi r24, '1'
	sbrc r27, 4
	ret
	ldi r24, '2'
	sbrc r27, 5
	ret
	ldi r24, '3'
	sbrc r27, 6
	ret
	ldi r24, 'A'
	sbrc r27, 7
	ret
	clr r24
 	ret
